{
  "change": {
    "prefix": "change",
    "body": [
      "pub trait Change<T: PartialOrd> {",
      "    fn chmin(&mut self, rhs: Self) -> bool;",
      "    fn chmax(&mut self, rhs: Self) -> bool;",
      "}",
      "impl<T: PartialOrd> Change<T> for T {",
      "    fn chmax(&mut self, rhs: Self) -> bool {",
      "        if *self < rhs {",
      "            *self = rhs;",
      "            true",
      "        } else {",
      "            false",
      "        }",
      "    }",
      "    fn chmin(&mut self, rhs: Self) -> bool {",
      "        if *self > rhs {",
      "            *self = rhs;",
      "            true",
      "        } else {",
      "            false",
      "        }",
      "    }",
      "}"
    ]
  },
  "change-trait": {
    "prefix": "change-trait",
    "body": [
      "pub trait Change<T: PartialOrd> {",
      "    fn chmin(&mut self, rhs: Self) -> bool;",
      "    fn chmax(&mut self, rhs: Self) -> bool;",
      "}"
    ]
  },
  "modint": {
    "prefix": "modint",
    "body": [
      "use std::ops::{Add, AddAssign, Mul, MulAssign, Sub, SubAssign};",
      "impl Sub<i64> for ModInt998244353 {",
      "    type Output = Self;",
      "    fn sub(self, rhs: i64) -> Self {",
      "        let val = (self.val - rhs).rem_euclid(Self::MODULO);",
      "        ModInt998244353 { val }",
      "    }",
      "}",
      "impl SubAssign for ModInt998244353 {",
      "    fn sub_assign(&mut self, rhs: Self) {",
      "        self.val = (self.val - rhs.val).rem_euclid(Self::MODULO);",
      "    }",
      "}",
      "impl Sub for ModInt998244353 {",
      "    type Output = Self;",
      "    fn sub(self, rhs: Self) -> Self {",
      "        let val = (self.val - rhs.val).rem_euclid(Self::MODULO);",
      "        ModInt998244353 { val }",
      "    }",
      "}",
      "impl Mul<i64> for ModInt998244353 {",
      "    type Output = Self;",
      "    fn mul(self, rhs: i64) -> Self {",
      "        let val = (self.val * rhs).rem_euclid(Self::MODULO);",
      "        ModInt998244353 { val }",
      "    }",
      "}",
      "impl MulAssign for ModInt998244353 {",
      "    fn mul_assign(&mut self, rhs: Self) {",
      "        self.val = (self.val * rhs.val).rem_euclid(Self::MODULO);",
      "    }",
      "}",
      "impl Mul for ModInt998244353 {",
      "    type Output = Self;",
      "    fn mul(self, rhs: Self) -> Self {",
      "        let val = (self.val * rhs.val).rem_euclid(Self::MODULO);",
      "        ModInt998244353 { val }",
      "    }",
      "}",
      "impl ModInt998244353 {",
      "    const MODULO: i64 = 998244353;",
      "    pub fn new() -> ModInt998244353 {",
      "        ModInt998244353 { val: 0 }",
      "    }",
      "    pub fn from(x: i64) -> ModInt998244353 {",
      "        let val = x.rem_euclid(Self::MODULO);",
      "        ModInt998244353 { val }",
      "    }",
      "}",
      "impl Add<i64> for ModInt998244353 {",
      "    type Output = Self;",
      "    fn add(self, rhs: i64) -> Self {",
      "        let val = (self.val + rhs).rem_euclid(Self::MODULO);",
      "        ModInt998244353 { val }",
      "    }",
      "}",
      "impl AddAssign for ModInt998244353 {",
      "    fn add_assign(&mut self, rhs: Self) {",
      "        self.val = (self.val + rhs.val).rem_euclid(Self::MODULO);",
      "    }",
      "}",
      "impl Add for ModInt998244353 {",
      "    type Output = Self;",
      "    fn add(self, rhs: Self) -> Self {",
      "        let val = (self.val + rhs.val).rem_euclid(Self::MODULO);",
      "        ModInt998244353 { val }",
      "    }",
      "}",
      "#[derive(Clone, Copy)]",
      "pub struct ModInt998244353 {",
      "    val: i64,",
      "}"
    ]
  },
  "modint-add": {
    "prefix": "modint-add",
    "body": [
      "impl Add for ModInt998244353 {",
      "    type Output = Self;",
      "    fn add(self, rhs: Self) -> Self {",
      "        let val = (self.val + rhs.val).rem_euclid(Self::MODULO);",
      "        ModInt998244353 { val }",
      "    }",
      "}"
    ]
  },
  "modint-add-assign": {
    "prefix": "modint-add-assign",
    "body": [
      "impl AddAssign for ModInt998244353 {",
      "    fn add_assign(&mut self, rhs: Self) {",
      "        self.val = (self.val + rhs.val).rem_euclid(Self::MODULO);",
      "    }",
      "}"
    ]
  },
  "modint-add-i64": {
    "prefix": "modint-add-i64",
    "body": [
      "impl Add<i64> for ModInt998244353 {",
      "    type Output = Self;",
      "    fn add(self, rhs: i64) -> Self {",
      "        let val = (self.val + rhs).rem_euclid(Self::MODULO);",
      "        ModInt998244353 { val }",
      "    }",
      "}"
    ]
  },
  "modint-impl": {
    "prefix": "modint-impl",
    "body": [
      "impl ModInt998244353 {",
      "    const MODULO: i64 = 998244353;",
      "    pub fn new() -> ModInt998244353 {",
      "        ModInt998244353 { val: 0 }",
      "    }",
      "    pub fn from(x: i64) -> ModInt998244353 {",
      "        let val = x.rem_euclid(Self::MODULO);",
      "        ModInt998244353 { val }",
      "    }",
      "}"
    ]
  },
  "modint-mul": {
    "prefix": "modint-mul",
    "body": [
      "impl Mul for ModInt998244353 {",
      "    type Output = Self;",
      "    fn mul(self, rhs: Self) -> Self {",
      "        let val = (self.val * rhs.val).rem_euclid(Self::MODULO);",
      "        ModInt998244353 { val }",
      "    }",
      "}"
    ]
  },
  "modint-mul-assign": {
    "prefix": "modint-mul-assign",
    "body": [
      "impl MulAssign for ModInt998244353 {",
      "    fn mul_assign(&mut self, rhs: Self) {",
      "        self.val = (self.val * rhs.val).rem_euclid(Self::MODULO);",
      "    }",
      "}"
    ]
  },
  "modint-mul-i64": {
    "prefix": "modint-mul-i64",
    "body": [
      "impl Mul<i64> for ModInt998244353 {",
      "    type Output = Self;",
      "    fn mul(self, rhs: i64) -> Self {",
      "        let val = (self.val * rhs).rem_euclid(Self::MODULO);",
      "        ModInt998244353 { val }",
      "    }",
      "}"
    ]
  },
  "modint-sub": {
    "prefix": "modint-sub",
    "body": [
      "impl Sub for ModInt998244353 {",
      "    type Output = Self;",
      "    fn sub(self, rhs: Self) -> Self {",
      "        let val = (self.val - rhs.val).rem_euclid(Self::MODULO);",
      "        ModInt998244353 { val }",
      "    }",
      "}"
    ]
  },
  "modint-sub-assign": {
    "prefix": "modint-sub-assign",
    "body": [
      "impl SubAssign for ModInt998244353 {",
      "    fn sub_assign(&mut self, rhs: Self) {",
      "        self.val = (self.val - rhs.val).rem_euclid(Self::MODULO);",
      "    }",
      "}"
    ]
  },
  "modint-sub-i64": {
    "prefix": "modint-sub-i64",
    "body": [
      "impl Sub<i64> for ModInt998244353 {",
      "    type Output = Self;",
      "    fn sub(self, rhs: i64) -> Self {",
      "        let val = (self.val - rhs).rem_euclid(Self::MODULO);",
      "        ModInt998244353 { val }",
      "    }",
      "}"
    ]
  },
  "segtree": {
    "prefix": "segtree",
    "body": [
      "pub trait Op<S> {",
      "    fn op(lhs: &S, rhs: &S) -> S;",
      "    fn e() -> S;",
      "}",
      "impl<S: Clone, F: Op<S>> SegmentTree<S, F> {",
      "    pub fn from(op: F, v: Vec<S>) -> SegmentTree<S, F> {",
      "        let n = v.len();",
      "        let log = Self::ceil_pow2(n);",
      "        let size = 1 << log;",
      "        let mut d = (0..2 * size).map(|_| F::e()).collect::<Vec<_>>();",
      "        for (i, x) in v.into_iter().enumerate() {",
      "            d[size + i] = x",
      "        }",
      "        let mut st = SegmentTree {",
      "            n,",
      "            log,",
      "            size,",
      "            op,",
      "            d,",
      "        };",
      "        for i in (1..=(size - 1)).rev() {",
      "            st.update(i);",
      "        }",
      "        st",
      "    }",
      "    pub fn set(&mut self, p: usize, x: S) {",
      "        let p = p + self.size;",
      "        self.d[p] = x;",
      "        for i in 1..=self.log {",
      "            self.update(p >> i);",
      "        }",
      "    }",
      "    pub fn get(&self, p: usize) -> &S {",
      "        &self.d[p + self.size]",
      "    }",
      "    pub fn prod(&mut self, l: usize, r: usize) -> S {",
      "        let mut sml = F::e();",
      "        let mut smr = F::e();",
      "        let mut l = l + self.size;",
      "        let mut r = r + self.size;",
      "        while l < r {",
      "            if l & 1 == 1 {",
      "                sml = F::op(&sml, &self.d[l]);",
      "                l += 1;",
      "            }",
      "            if r & 1 == 1 {",
      "                r -= 1;",
      "                smr = F::op(&self.d[r], &smr);",
      "                l >>= 1;",
      "                r >>= 1;",
      "            }",
      "        }",
      "        F::op(&sml, &smr)",
      "    }",
      "    pub fn all_prod(&self) -> S {",
      "        self.d[1].clone()",
      "    }",
      "    fn update(&mut self, k: usize) {",
      "        self.d[k] = F::op(&self.d[2 * k], &self.d[2 * k + 1]);",
      "    }",
      "    fn ceil_pow2(n: usize) -> usize {",
      "        let mut m = 1;",
      "        let mut log = 0;",
      "        while n > m {",
      "            m <<= 1;",
      "            log += 1;",
      "        }",
      "        log",
      "    }",
      "}",
      "pub struct SegmentTree<S: Clone, F: Op<S>> {",
      "    n: usize,",
      "    log: usize,",
      "    size: usize,",
      "    op: F,",
      "    d: Vec<S>,",
      "}"
    ]
  },
  "segtree-impl": {
    "prefix": "segtree-impl",
    "body": [
      "impl<S: Clone, F: Op<S>> SegmentTree<S, F> {",
      "    pub fn from(op: F, v: Vec<S>) -> SegmentTree<S, F> {",
      "        let n = v.len();",
      "        let log = Self::ceil_pow2(n);",
      "        let size = 1 << log;",
      "        let mut d = (0..2 * size).map(|_| F::e()).collect::<Vec<_>>();",
      "        for (i, x) in v.into_iter().enumerate() {",
      "            d[size + i] = x",
      "        }",
      "        let mut st = SegmentTree {",
      "            n,",
      "            log,",
      "            size,",
      "            op,",
      "            d,",
      "        };",
      "        for i in (1..=(size - 1)).rev() {",
      "            st.update(i);",
      "        }",
      "        st",
      "    }",
      "    pub fn set(&mut self, p: usize, x: S) {",
      "        let p = p + self.size;",
      "        self.d[p] = x;",
      "        for i in 1..=self.log {",
      "            self.update(p >> i);",
      "        }",
      "    }",
      "    pub fn get(&self, p: usize) -> &S {",
      "        &self.d[p + self.size]",
      "    }",
      "    pub fn prod(&mut self, l: usize, r: usize) -> S {",
      "        let mut sml = F::e();",
      "        let mut smr = F::e();",
      "        let mut l = l + self.size;",
      "        let mut r = r + self.size;",
      "        while l < r {",
      "            if l & 1 == 1 {",
      "                sml = F::op(&sml, &self.d[l]);",
      "                l += 1;",
      "            }",
      "            if r & 1 == 1 {",
      "                r -= 1;",
      "                smr = F::op(&self.d[r], &smr);",
      "                l >>= 1;",
      "                r >>= 1;",
      "            }",
      "        }",
      "        F::op(&sml, &smr)",
      "    }",
      "    pub fn all_prod(&self) -> S {",
      "        self.d[1].clone()",
      "    }",
      "    fn update(&mut self, k: usize) {",
      "        self.d[k] = F::op(&self.d[2 * k], &self.d[2 * k + 1]);",
      "    }",
      "    fn ceil_pow2(n: usize) -> usize {",
      "        let mut m = 1;",
      "        let mut log = 0;",
      "        while n > m {",
      "            m <<= 1;",
      "            log += 1;",
      "        }",
      "        log",
      "    }",
      "}"
    ]
  },
  "segtree-op": {
    "prefix": "segtree-op",
    "body": [
      "pub trait Op<S> {",
      "    fn op(lhs: &S, rhs: &S) -> S;",
      "    fn e() -> S;",
      "}"
    ]
  },
  "segtree-sum": {
    "prefix": "segtree-sum",
    "body": [
      "impl Op<i64> for Sum {",
      "    fn op(lhs: &i64, rhs: &i64) -> i64 {",
      "        lhs + rhs",
      "    }",
      "    fn e() -> i64 {",
      "        0",
      "    }",
      "}",
      "pub struct SegmentTree<S: Clone, F: Op<S>> {",
      "    n: usize,",
      "    log: usize,",
      "    size: usize,",
      "    op: F,",
      "    d: Vec<S>,",
      "}",
      "pub trait Op<S> {",
      "    fn op(lhs: &S, rhs: &S) -> S;",
      "    fn e() -> S;",
      "}",
      "impl<S: Clone, F: Op<S>> SegmentTree<S, F> {",
      "    pub fn from(op: F, v: Vec<S>) -> SegmentTree<S, F> {",
      "        let n = v.len();",
      "        let log = Self::ceil_pow2(n);",
      "        let size = 1 << log;",
      "        let mut d = (0..2 * size).map(|_| F::e()).collect::<Vec<_>>();",
      "        for (i, x) in v.into_iter().enumerate() {",
      "            d[size + i] = x",
      "        }",
      "        let mut st = SegmentTree {",
      "            n,",
      "            log,",
      "            size,",
      "            op,",
      "            d,",
      "        };",
      "        for i in (1..=(size - 1)).rev() {",
      "            st.update(i);",
      "        }",
      "        st",
      "    }",
      "    pub fn set(&mut self, p: usize, x: S) {",
      "        let p = p + self.size;",
      "        self.d[p] = x;",
      "        for i in 1..=self.log {",
      "            self.update(p >> i);",
      "        }",
      "    }",
      "    pub fn get(&self, p: usize) -> &S {",
      "        &self.d[p + self.size]",
      "    }",
      "    pub fn prod(&mut self, l: usize, r: usize) -> S {",
      "        let mut sml = F::e();",
      "        let mut smr = F::e();",
      "        let mut l = l + self.size;",
      "        let mut r = r + self.size;",
      "        while l < r {",
      "            if l & 1 == 1 {",
      "                sml = F::op(&sml, &self.d[l]);",
      "                l += 1;",
      "            }",
      "            if r & 1 == 1 {",
      "                r -= 1;",
      "                smr = F::op(&self.d[r], &smr);",
      "                l >>= 1;",
      "                r >>= 1;",
      "            }",
      "        }",
      "        F::op(&sml, &smr)",
      "    }",
      "    pub fn all_prod(&self) -> S {",
      "        self.d[1].clone()",
      "    }",
      "    fn update(&mut self, k: usize) {",
      "        self.d[k] = F::op(&self.d[2 * k], &self.d[2 * k + 1]);",
      "    }",
      "    fn ceil_pow2(n: usize) -> usize {",
      "        let mut m = 1;",
      "        let mut log = 0;",
      "        while n > m {",
      "            m <<= 1;",
      "            log += 1;",
      "        }",
      "        log",
      "    }",
      "}",
      "pub struct Sum {}"
    ]
  },
  "sum-impl": {
    "prefix": "sum-impl",
    "body": [
      "impl Op<i64> for Sum {",
      "    fn op(lhs: &i64, rhs: &i64) -> i64 {",
      "        lhs + rhs",
      "    }",
      "    fn e() -> i64 {",
      "        0",
      "    }",
      "}"
    ]
  },
  "vvec": {
    "prefix": "vvec",
    "body": [
      "#[macro_export]",
      "macro_rules! vvec {",
      "    (\\$ val : expr ; \\$ a : expr , \\$ b : expr ) => {",
      "        vec![vec![\\$val; \\$b]; \\$a]",
      "    };",
      "}"
    ]
  },
  "vvvec": {
    "prefix": "vvvec",
    "body": [
      "#[macro_export]",
      "macro_rules! vvvec {",
      "    (\\$ val : expr ; \\$ a : expr , \\$ b : expr , \\$ c : expr ) => {",
      "        vec![vec![vec![\\$val; \\$c]; \\$b]; \\$a]",
      "    };",
      "}"
    ]
  }
}
