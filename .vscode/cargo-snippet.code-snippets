{
  "change": {
    "prefix": "change",
    "body": [
      "pub trait Change<T: PartialOrd> {",
      "    fn chmin(&mut self, rhs: Self) -> bool;",
      "    fn chmax(&mut self, rhs: Self) -> bool;",
      "}",
      "impl<T: PartialOrd> Change<T> for T {",
      "    fn chmax(&mut self, rhs: Self) -> bool {",
      "        if *self < rhs {",
      "            *self = rhs;",
      "            true",
      "        } else {",
      "            false",
      "        }",
      "    }",
      "    fn chmin(&mut self, rhs: Self) -> bool {",
      "        if *self > rhs {",
      "            *self = rhs;",
      "            true",
      "        } else {",
      "            false",
      "        }",
      "    }",
      "}"
    ]
  },
  "change-trait": {
    "prefix": "change-trait",
    "body": [
      "pub trait Change<T: PartialOrd> {",
      "    fn chmin(&mut self, rhs: Self) -> bool;",
      "    fn chmax(&mut self, rhs: Self) -> bool;",
      "}"
    ]
  },
  "gcd": {
    "prefix": "gcd",
    "body": [
      "pub fn gcd(a: i64, b: i64, x: &mut i64, y: &mut i64) -> i64 {",
      "    if a != 0 {",
      "        let mut d = gcd(b % a, a, x, y);",
      "        *y -= (b / a) * *x;",
      "        std::mem::swap(x, y);",
      "        if d < 0 {",
      "            d = -d;",
      "            *x = -*x;",
      "            *y = -*y;",
      "        }",
      "        d",
      "    } else {",
      "        *x = 0;",
      "        *y = 1;",
      "        b",
      "    }",
      "}"
    ]
  },
  "gcd-internal": {
    "prefix": "gcd-internal",
    "body": [
      "pub fn gcd(a: i64, b: i64, x: &mut i64, y: &mut i64) -> i64 {",
      "    if a != 0 {",
      "        let mut d = gcd(b % a, a, x, y);",
      "        *y -= (b / a) * *x;",
      "        std::mem::swap(x, y);",
      "        if d < 0 {",
      "            d = -d;",
      "            *x = -*x;",
      "            *y = -*y;",
      "        }",
      "        d",
      "    } else {",
      "        *x = 0;",
      "        *y = 1;",
      "        b",
      "    }",
      "}"
    ]
  },
  "lazy_segtre-action": {
    "prefix": "lazy_segtre-action",
    "body": [
      "pub trait Action<S> {",
      "    fn apply(&self, x: &S) -> S;",
      "    fn composition(&self, rhs: &Self) -> Self;",
      "    fn id() -> Self;",
      "}"
    ]
  },
  "lazy_segtre-op": {
    "prefix": "lazy_segtre-op",
    "body": [
      "pub trait Op<S> {",
      "    fn op(lhs: &S, rhs: &S) -> S;",
      "    fn e() -> S;",
      "}"
    ]
  },
  "lazy_segtree": {
    "prefix": "lazy_segtree",
    "body": [
      "use std::marker::PhantomData;",
      "impl<S: Clone, T: Op<S>, U: Action<S> + Clone> LazySegmentTree<S, T, U> {",
      "    pub fn from(v: Vec<S>) -> LazySegmentTree<S, T, U> {",
      "        let n = v.len();",
      "        let log = Self::ceil_pow2(n);",
      "        let size = 1 << log;",
      "        let mut d = (0..2 * size).map(|_| T::e()).collect::<Vec<_>>();",
      "        let lz = (0..size).map(|_| U::id()).collect::<Vec<_>>();",
      "        for (i, x) in v.into_iter().enumerate() {",
      "            d[size + i] = x;",
      "        }",
      "        let mut lst = LazySegmentTree {",
      "            n,",
      "            log,",
      "            size,",
      "            d,",
      "            _marker: PhantomData,",
      "            lz,",
      "        };",
      "        for i in (1..=size - 1).rev() {",
      "            lst.update(i);",
      "        }",
      "        lst",
      "    }",
      "    pub fn set(&mut self, p: usize, x: S) {",
      "        let p = p + self.size;",
      "        for i in (1..=self.log).rev() {",
      "            self.push(p >> i);",
      "        }",
      "        self.d[p] = x;",
      "        for i in 1..=self.log {",
      "            self.update(p >> i);",
      "        }",
      "    }",
      "    pub fn get(&mut self, p: usize) -> &S {",
      "        let p = p + self.size;",
      "        for i in (1..=self.log).rev() {",
      "            self.push(p >> i);",
      "        }",
      "        &self.d[p]",
      "    }",
      "    pub fn prod(&mut self, l: usize, r: usize) -> S {",
      "        if l == r {",
      "            return T::e();",
      "        }",
      "        let mut l = l + self.size;",
      "        let mut r = r + self.size;",
      "        for i in (1..=self.log).rev() {",
      "            if (l >> i) << i != l {",
      "                self.push(l >> i);",
      "            }",
      "            if ((r >> i) << i != r) {",
      "                self.push((r - 1) >> i);",
      "            }",
      "        }",
      "        let mut sml = T::e();",
      "        let mut smr = T::e();",
      "        while l < r {",
      "            if l & 1 == 1 {",
      "                sml = T::op(&sml, &self.d[l]);",
      "                l += 1;",
      "            }",
      "            if r & 1 == 1 {",
      "                r -= 1;",
      "                smr = T::op(&self.d[r], &smr);",
      "            }",
      "            l >>= 1;",
      "            r >>= 1;",
      "        }",
      "        T::op(&sml, &smr)",
      "    }",
      "    pub fn all_prod(&self) -> S {",
      "        self.d[1].clone()",
      "    }",
      "    pub fn apply_at(&mut self, p: usize, f: U) {",
      "        let p = p + self.size;",
      "        for i in (1..=self.log).rev() {",
      "            self.push(p >> i);",
      "        }",
      "        self.d[p] = f.apply(&self.d[p]);",
      "        for i in 1..=self.log {",
      "            self.update(p >> i);",
      "        }",
      "    }",
      "    pub fn apply_range(&mut self, l: usize, r: usize, f: &U) {",
      "        if l == r {",
      "            return;",
      "        }",
      "        let l = l + self.size;",
      "        let r = r + self.size;",
      "        for i in (1..=self.log).rev() {",
      "            if (l >> i) << i != l {",
      "                self.push(l >> i);",
      "            }",
      "            if (r >> i) << i != r {",
      "                self.push((r - 1) >> i);",
      "            }",
      "        }",
      "        {",
      "            let mut l = l;",
      "            let mut r = r;",
      "            while l < r {",
      "                if l & 1 == 1 {",
      "                    self.all_apply(l, &f);",
      "                    l += 1;",
      "                }",
      "                if r & 1 == 1 {",
      "                    r -= 1;",
      "                    self.all_apply(r, &f);",
      "                }",
      "                l >>= 1;",
      "                r >>= 1;",
      "            }",
      "        }",
      "        for i in 1..=self.log {",
      "            if ((l >> i) << i) != l {",
      "                self.update(l >> i);",
      "            }",
      "            if ((r >> i) << i) != r {",
      "                self.update((r - 1) >> i);",
      "            }",
      "        }",
      "    }",
      "    fn update(&mut self, k: usize) {",
      "        self.d[k] = T::op(&self.d[2 * k], &self.d[2 * k + 1]);",
      "    }",
      "    fn all_apply(&mut self, k: usize, f: &U) {",
      "        self.d[k] = f.apply(&self.d[k]);",
      "        if k < self.size {",
      "            self.lz[k] = f.composition(&self.lz[k]);",
      "        }",
      "    }",
      "    fn push(&mut self, k: usize) {",
      "        let f = self.lz[k].clone();",
      "        self.all_apply(2 * k, &f);",
      "        self.all_apply(2 * k + 1, &f);",
      "        self.lz[k] = U::id();",
      "    }",
      "    fn ceil_pow2(n: usize) -> usize {",
      "        let mut m = 1;",
      "        let mut log = 0;",
      "        while n > m {",
      "            m <<= 1;",
      "            log += 1;",
      "        }",
      "        log",
      "    }",
      "}",
      "pub trait Op<S> {",
      "    fn op(lhs: &S, rhs: &S) -> S;",
      "    fn e() -> S;",
      "}",
      "pub trait Action<S> {",
      "    fn apply(&self, x: &S) -> S;",
      "    fn composition(&self, rhs: &Self) -> Self;",
      "    fn id() -> Self;",
      "}",
      "struct LazySegmentTree<S, T: Op<S>, U: Action<S>> {",
      "    n: usize,",
      "    log: usize,",
      "    size: usize,",
      "    d: Vec<S>,",
      "    _marker: PhantomData<T>,",
      "    lz: Vec<U>,",
      "}"
    ]
  },
  "lazy_segtree-impl": {
    "prefix": "lazy_segtree-impl",
    "body": [
      "impl<S: Clone, T: Op<S>, U: Action<S> + Clone> LazySegmentTree<S, T, U> {",
      "    pub fn from(v: Vec<S>) -> LazySegmentTree<S, T, U> {",
      "        let n = v.len();",
      "        let log = Self::ceil_pow2(n);",
      "        let size = 1 << log;",
      "        let mut d = (0..2 * size).map(|_| T::e()).collect::<Vec<_>>();",
      "        let lz = (0..size).map(|_| U::id()).collect::<Vec<_>>();",
      "        for (i, x) in v.into_iter().enumerate() {",
      "            d[size + i] = x;",
      "        }",
      "        let mut lst = LazySegmentTree {",
      "            n,",
      "            log,",
      "            size,",
      "            d,",
      "            _marker: PhantomData,",
      "            lz,",
      "        };",
      "        for i in (1..=size - 1).rev() {",
      "            lst.update(i);",
      "        }",
      "        lst",
      "    }",
      "    pub fn set(&mut self, p: usize, x: S) {",
      "        let p = p + self.size;",
      "        for i in (1..=self.log).rev() {",
      "            self.push(p >> i);",
      "        }",
      "        self.d[p] = x;",
      "        for i in 1..=self.log {",
      "            self.update(p >> i);",
      "        }",
      "    }",
      "    pub fn get(&mut self, p: usize) -> &S {",
      "        let p = p + self.size;",
      "        for i in (1..=self.log).rev() {",
      "            self.push(p >> i);",
      "        }",
      "        &self.d[p]",
      "    }",
      "    pub fn prod(&mut self, l: usize, r: usize) -> S {",
      "        if l == r {",
      "            return T::e();",
      "        }",
      "        let mut l = l + self.size;",
      "        let mut r = r + self.size;",
      "        for i in (1..=self.log).rev() {",
      "            if (l >> i) << i != l {",
      "                self.push(l >> i);",
      "            }",
      "            if ((r >> i) << i != r) {",
      "                self.push((r - 1) >> i);",
      "            }",
      "        }",
      "        let mut sml = T::e();",
      "        let mut smr = T::e();",
      "        while l < r {",
      "            if l & 1 == 1 {",
      "                sml = T::op(&sml, &self.d[l]);",
      "                l += 1;",
      "            }",
      "            if r & 1 == 1 {",
      "                r -= 1;",
      "                smr = T::op(&self.d[r], &smr);",
      "            }",
      "            l >>= 1;",
      "            r >>= 1;",
      "        }",
      "        T::op(&sml, &smr)",
      "    }",
      "    pub fn all_prod(&self) -> S {",
      "        self.d[1].clone()",
      "    }",
      "    pub fn apply_at(&mut self, p: usize, f: U) {",
      "        let p = p + self.size;",
      "        for i in (1..=self.log).rev() {",
      "            self.push(p >> i);",
      "        }",
      "        self.d[p] = f.apply(&self.d[p]);",
      "        for i in 1..=self.log {",
      "            self.update(p >> i);",
      "        }",
      "    }",
      "    pub fn apply_range(&mut self, l: usize, r: usize, f: &U) {",
      "        if l == r {",
      "            return;",
      "        }",
      "        let l = l + self.size;",
      "        let r = r + self.size;",
      "        for i in (1..=self.log).rev() {",
      "            if (l >> i) << i != l {",
      "                self.push(l >> i);",
      "            }",
      "            if (r >> i) << i != r {",
      "                self.push((r - 1) >> i);",
      "            }",
      "        }",
      "        {",
      "            let mut l = l;",
      "            let mut r = r;",
      "            while l < r {",
      "                if l & 1 == 1 {",
      "                    self.all_apply(l, &f);",
      "                    l += 1;",
      "                }",
      "                if r & 1 == 1 {",
      "                    r -= 1;",
      "                    self.all_apply(r, &f);",
      "                }",
      "                l >>= 1;",
      "                r >>= 1;",
      "            }",
      "        }",
      "        for i in 1..=self.log {",
      "            if ((l >> i) << i) != l {",
      "                self.update(l >> i);",
      "            }",
      "            if ((r >> i) << i) != r {",
      "                self.update((r - 1) >> i);",
      "            }",
      "        }",
      "    }",
      "    fn update(&mut self, k: usize) {",
      "        self.d[k] = T::op(&self.d[2 * k], &self.d[2 * k + 1]);",
      "    }",
      "    fn all_apply(&mut self, k: usize, f: &U) {",
      "        self.d[k] = f.apply(&self.d[k]);",
      "        if k < self.size {",
      "            self.lz[k] = f.composition(&self.lz[k]);",
      "        }",
      "    }",
      "    fn push(&mut self, k: usize) {",
      "        let f = self.lz[k].clone();",
      "        self.all_apply(2 * k, &f);",
      "        self.all_apply(2 * k + 1, &f);",
      "        self.lz[k] = U::id();",
      "    }",
      "    fn ceil_pow2(n: usize) -> usize {",
      "        let mut m = 1;",
      "        let mut log = 0;",
      "        while n > m {",
      "            m <<= 1;",
      "            log += 1;",
      "        }",
      "        log",
      "    }",
      "}"
    ]
  },
  "min_heap": {
    "prefix": "min_heap",
    "body": [
      "use std::cmp::Reverse;",
      "use std::collections::BinaryHeap;",
      "impl<T: Ord> MinHeap<T> {",
      "    pub fn new() -> Self {",
      "        let heap = BinaryHeap::new();",
      "        MinHeap { heap }",
      "    }",
      "    pub fn push(&mut self, x: T) {",
      "        self.heap.push(Reverse(x));",
      "    }",
      "    pub fn pop(&mut self) -> Option<T> {",
      "        self.heap.pop().map(|x| x.0)",
      "    }",
      "    pub fn peek(&self) -> Option<&T> {",
      "        self.heap.peek().map(|x| &x.0)",
      "    }",
      "    pub fn len(&self) -> usize {",
      "        self.heap.len()",
      "    }",
      "    pub fn is_empty(&self) -> bool {",
      "        self.heap.is_empty()",
      "    }",
      "}",
      "#[derive(Clone, Debug)]",
      "struct MinHeap<T> {",
      "    heap: BinaryHeap<Reverse<T>>,",
      "}"
    ]
  },
  "min_heap-impl": {
    "prefix": "min_heap-impl",
    "body": [
      "impl<T: Ord> MinHeap<T> {",
      "    pub fn new() -> Self {",
      "        let heap = BinaryHeap::new();",
      "        MinHeap { heap }",
      "    }",
      "    pub fn push(&mut self, x: T) {",
      "        self.heap.push(Reverse(x));",
      "    }",
      "    pub fn pop(&mut self) -> Option<T> {",
      "        self.heap.pop().map(|x| x.0)",
      "    }",
      "    pub fn peek(&self) -> Option<&T> {",
      "        self.heap.peek().map(|x| &x.0)",
      "    }",
      "    pub fn len(&self) -> usize {",
      "        self.heap.len()",
      "    }",
      "    pub fn is_empty(&self) -> bool {",
      "        self.heap.is_empty()",
      "    }",
      "}"
    ]
  },
  "modint": {
    "prefix": "modint",
    "body": [
      "use std::ops::{Add, AddAssign, Mul, MulAssign, Sub, SubAssign};",
      "impl Sub<i64> for ModInt {",
      "    type Output = Self;",
      "    fn sub(self, rhs: i64) -> Self {",
      "        let val = (self.val - rhs).rem_euclid(Self::MODULO);",
      "        ModInt { val }",
      "    }",
      "}",
      "impl SubAssign for ModInt {",
      "    fn sub_assign(&mut self, rhs: Self) {",
      "        self.val = (self.val - rhs.val).rem_euclid(Self::MODULO);",
      "    }",
      "}",
      "impl Sub for ModInt {",
      "    type Output = Self;",
      "    fn sub(self, rhs: Self) -> Self {",
      "        let val = (self.val - rhs.val).rem_euclid(Self::MODULO);",
      "        ModInt { val }",
      "    }",
      "}",
      "impl Mul<i64> for ModInt {",
      "    type Output = Self;",
      "    fn mul(self, rhs: i64) -> Self {",
      "        let val = (self.val * rhs).rem_euclid(Self::MODULO);",
      "        ModInt { val }",
      "    }",
      "}",
      "impl MulAssign for ModInt {",
      "    fn mul_assign(&mut self, rhs: Self) {",
      "        self.val = (self.val * rhs.val).rem_euclid(Self::MODULO);",
      "    }",
      "}",
      "impl Mul for ModInt {",
      "    type Output = Self;",
      "    fn mul(self, rhs: Self) -> Self {",
      "        let val = (self.val * rhs.val).rem_euclid(Self::MODULO);",
      "        ModInt { val }",
      "    }",
      "}",
      "impl Inv for ModInt {",
      "    fn inv(self) -> Self {",
      "        let mut x = 0;",
      "        let mut y = 0;",
      "        gcd(self.val, Self::MODULO, &mut x, &mut y);",
      "        ModInt {",
      "            val: x.rem_euclid(Self::MODULO),",
      "        }",
      "    }",
      "}",
      "pub trait Inv {",
      "    fn inv(self) -> Self;",
      "}",
      "pub fn gcd(a: i64, b: i64, x: &mut i64, y: &mut i64) -> i64 {",
      "    if a != 0 {",
      "        let mut d = gcd(b % a, a, x, y);",
      "        *y -= (b / a) * *x;",
      "        std::mem::swap(x, y);",
      "        if d < 0 {",
      "            d = -d;",
      "            *x = -*x;",
      "            *y = -*y;",
      "        }",
      "        d",
      "    } else {",
      "        *x = 0;",
      "        *y = 1;",
      "        b",
      "    }",
      "}",
      "impl ModInt {",
      "    pub const MODULO: i64 = 998_244_353;",
      "    pub fn new() -> ModInt {",
      "        ModInt { val: 0 }",
      "    }",
      "    pub fn from(x: i64) -> ModInt {",
      "        let val = x.rem_euclid(Self::MODULO);",
      "        ModInt { val }",
      "    }",
      "    pub fn binom(n: i64, k: i64) -> ModInt {",
      "        let mut val = ModInt::from(1);",
      "        for i in 1..=k {",
      "            val *= ModInt::from(n - i + 1) * ModInt::from(i).inv()",
      "        }",
      "        val",
      "    }",
      "    pub fn pow(&self, n: i64) -> ModInt {",
      "        if n == 0 {",
      "            return ModInt::from(1);",
      "        }",
      "        let (a, n) = if n > 0 {",
      "            (self.clone(), n)",
      "        } else {",
      "            (self.inv(), -n)",
      "        };",
      "        let mut k = 0;",
      "        while n >= 1 << k {",
      "            k += 1;",
      "        }",
      "        let mut x = ModInt::from(1);",
      "        for i in (0..k).rev() {",
      "            x = if (n >> i) & 1 == 1 { x * x * a } else { x * x };",
      "        }",
      "        x",
      "    }",
      "}",
      "impl Add<i64> for ModInt {",
      "    type Output = Self;",
      "    fn add(self, rhs: i64) -> Self {",
      "        let val = (self.val + rhs).rem_euclid(Self::MODULO);",
      "        ModInt { val }",
      "    }",
      "}",
      "impl AddAssign for ModInt {",
      "    fn add_assign(&mut self, rhs: Self) {",
      "        self.val = (self.val + rhs.val).rem_euclid(Self::MODULO);",
      "    }",
      "}",
      "impl Add for ModInt {",
      "    type Output = Self;",
      "    fn add(self, rhs: Self) -> Self {",
      "        let val = (self.val + rhs.val).rem_euclid(Self::MODULO);",
      "        ModInt { val }",
      "    }",
      "}",
      "#[derive(Clone, Copy, Debug, PartialEq, Eq)]",
      "pub struct ModInt {",
      "    val: i64,",
      "}"
    ]
  },
  "modint-add": {
    "prefix": "modint-add",
    "body": [
      "impl Add for ModInt {",
      "    type Output = Self;",
      "    fn add(self, rhs: Self) -> Self {",
      "        let val = (self.val + rhs.val).rem_euclid(Self::MODULO);",
      "        ModInt { val }",
      "    }",
      "}"
    ]
  },
  "modint-add-assign": {
    "prefix": "modint-add-assign",
    "body": [
      "impl AddAssign for ModInt {",
      "    fn add_assign(&mut self, rhs: Self) {",
      "        self.val = (self.val + rhs.val).rem_euclid(Self::MODULO);",
      "    }",
      "}"
    ]
  },
  "modint-add-i64": {
    "prefix": "modint-add-i64",
    "body": [
      "impl Add<i64> for ModInt {",
      "    type Output = Self;",
      "    fn add(self, rhs: i64) -> Self {",
      "        let val = (self.val + rhs).rem_euclid(Self::MODULO);",
      "        ModInt { val }",
      "    }",
      "}"
    ]
  },
  "modint-impl": {
    "prefix": "modint-impl",
    "body": [
      "impl ModInt {",
      "    pub const MODULO: i64 = 998_244_353;",
      "    pub fn new() -> ModInt {",
      "        ModInt { val: 0 }",
      "    }",
      "    pub fn from(x: i64) -> ModInt {",
      "        let val = x.rem_euclid(Self::MODULO);",
      "        ModInt { val }",
      "    }",
      "    pub fn binom(n: i64, k: i64) -> ModInt {",
      "        let mut val = ModInt::from(1);",
      "        for i in 1..=k {",
      "            val *= ModInt::from(n - i + 1) * ModInt::from(i).inv()",
      "        }",
      "        val",
      "    }",
      "    pub fn pow(&self, n: i64) -> ModInt {",
      "        if n == 0 {",
      "            return ModInt::from(1);",
      "        }",
      "        let (a, n) = if n > 0 {",
      "            (self.clone(), n)",
      "        } else {",
      "            (self.inv(), -n)",
      "        };",
      "        let mut k = 0;",
      "        while n >= 1 << k {",
      "            k += 1;",
      "        }",
      "        let mut x = ModInt::from(1);",
      "        for i in (0..k).rev() {",
      "            x = if (n >> i) & 1 == 1 { x * x * a } else { x * x };",
      "        }",
      "        x",
      "    }",
      "}"
    ]
  },
  "modint-inv-impl": {
    "prefix": "modint-inv-impl",
    "body": [
      "pub trait Inv {",
      "    fn inv(self) -> Self;",
      "}",
      "pub fn gcd(a: i64, b: i64, x: &mut i64, y: &mut i64) -> i64 {",
      "    if a != 0 {",
      "        let mut d = gcd(b % a, a, x, y);",
      "        *y -= (b / a) * *x;",
      "        std::mem::swap(x, y);",
      "        if d < 0 {",
      "            d = -d;",
      "            *x = -*x;",
      "            *y = -*y;",
      "        }",
      "        d",
      "    } else {",
      "        *x = 0;",
      "        *y = 1;",
      "        b",
      "    }",
      "}",
      "impl Inv for ModInt {",
      "    fn inv(self) -> Self {",
      "        let mut x = 0;",
      "        let mut y = 0;",
      "        gcd(self.val, Self::MODULO, &mut x, &mut y);",
      "        ModInt {",
      "            val: x.rem_euclid(Self::MODULO),",
      "        }",
      "    }",
      "}"
    ]
  },
  "modint-inv-trait": {
    "prefix": "modint-inv-trait",
    "body": [
      "pub trait Inv {",
      "    fn inv(self) -> Self;",
      "}"
    ]
  },
  "modint-mul": {
    "prefix": "modint-mul",
    "body": [
      "impl Mul for ModInt {",
      "    type Output = Self;",
      "    fn mul(self, rhs: Self) -> Self {",
      "        let val = (self.val * rhs.val).rem_euclid(Self::MODULO);",
      "        ModInt { val }",
      "    }",
      "}"
    ]
  },
  "modint-mul-assign": {
    "prefix": "modint-mul-assign",
    "body": [
      "impl MulAssign for ModInt {",
      "    fn mul_assign(&mut self, rhs: Self) {",
      "        self.val = (self.val * rhs.val).rem_euclid(Self::MODULO);",
      "    }",
      "}"
    ]
  },
  "modint-mul-i64": {
    "prefix": "modint-mul-i64",
    "body": [
      "impl Mul<i64> for ModInt {",
      "    type Output = Self;",
      "    fn mul(self, rhs: i64) -> Self {",
      "        let val = (self.val * rhs).rem_euclid(Self::MODULO);",
      "        ModInt { val }",
      "    }",
      "}"
    ]
  },
  "modint-sub": {
    "prefix": "modint-sub",
    "body": [
      "impl Sub for ModInt {",
      "    type Output = Self;",
      "    fn sub(self, rhs: Self) -> Self {",
      "        let val = (self.val - rhs.val).rem_euclid(Self::MODULO);",
      "        ModInt { val }",
      "    }",
      "}"
    ]
  },
  "modint-sub-assign": {
    "prefix": "modint-sub-assign",
    "body": [
      "impl SubAssign for ModInt {",
      "    fn sub_assign(&mut self, rhs: Self) {",
      "        self.val = (self.val - rhs.val).rem_euclid(Self::MODULO);",
      "    }",
      "}"
    ]
  },
  "modint-sub-i64": {
    "prefix": "modint-sub-i64",
    "body": [
      "impl Sub<i64> for ModInt {",
      "    type Output = Self;",
      "    fn sub(self, rhs: i64) -> Self {",
      "        let val = (self.val - rhs).rem_euclid(Self::MODULO);",
      "        ModInt { val }",
      "    }",
      "}"
    ]
  },
  "segtree": {
    "prefix": "segtree",
    "body": [
      "pub trait Op<S> {",
      "    fn op(lhs: &S, rhs: &S) -> S;",
      "    fn e() -> S;",
      "}",
      "impl<S: Clone, F: Op<S>> SegmentTree<S, F> {",
      "    pub fn from(v: Vec<S>) -> SegmentTree<S, F> {",
      "        let n = v.len();",
      "        let log = Self::ceil_pow2(n);",
      "        let size = 1 << log;",
      "        let mut d = (0..2 * size).map(|_| F::e()).collect::<Vec<_>>();",
      "        for (i, x) in v.into_iter().enumerate() {",
      "            d[size + i] = x",
      "        }",
      "        let mut st = SegmentTree {",
      "            n,",
      "            log,",
      "            size,",
      "            d,",
      "            _marker: PhantomData,",
      "        };",
      "        for i in (1..=(size - 1)).rev() {",
      "            st.update(i);",
      "        }",
      "        st",
      "    }",
      "    pub fn set(&mut self, p: usize, x: S) {",
      "        let p = p + self.size;",
      "        self.d[p] = x;",
      "        for i in 1..=self.log {",
      "            self.update(p >> i);",
      "        }",
      "    }",
      "    pub fn get(&self, p: usize) -> &S {",
      "        &self.d[p + self.size]",
      "    }",
      "    pub fn prod(&mut self, l: usize, r: usize) -> S {",
      "        let mut sml = F::e();",
      "        let mut smr = F::e();",
      "        let mut l = l + self.size;",
      "        let mut r = r + self.size;",
      "        while l < r {",
      "            if l & 1 == 1 {",
      "                sml = F::op(&sml, &self.d[l]);",
      "                l += 1;",
      "            }",
      "            if r & 1 == 1 {",
      "                r -= 1;",
      "                smr = F::op(&self.d[r], &smr);",
      "            }",
      "            l >>= 1;",
      "            r >>= 1;",
      "        }",
      "        F::op(&sml, &smr)",
      "    }",
      "    pub fn all_prod(&self) -> S {",
      "        self.d[1].clone()",
      "    }",
      "    fn update(&mut self, k: usize) {",
      "        self.d[k] = F::op(&self.d[2 * k], &self.d[2 * k + 1]);",
      "    }",
      "    fn ceil_pow2(n: usize) -> usize {",
      "        let mut m = 1;",
      "        let mut log = 0;",
      "        while n > m {",
      "            m <<= 1;",
      "            log += 1;",
      "        }",
      "        log",
      "    }",
      "}",
      "pub struct SegmentTree<S: Clone, F: Op<S>> {",
      "    n: usize,",
      "    log: usize,",
      "    size: usize,",
      "    d: Vec<S>,",
      "    _marker: PhantomData<F>,",
      "}"
    ]
  },
  "segtree-impl": {
    "prefix": "segtree-impl",
    "body": [
      "impl<S: Clone, F: Op<S>> SegmentTree<S, F> {",
      "    pub fn from(v: Vec<S>) -> SegmentTree<S, F> {",
      "        let n = v.len();",
      "        let log = Self::ceil_pow2(n);",
      "        let size = 1 << log;",
      "        let mut d = (0..2 * size).map(|_| F::e()).collect::<Vec<_>>();",
      "        for (i, x) in v.into_iter().enumerate() {",
      "            d[size + i] = x",
      "        }",
      "        let mut st = SegmentTree {",
      "            n,",
      "            log,",
      "            size,",
      "            d,",
      "            _marker: PhantomData,",
      "        };",
      "        for i in (1..=(size - 1)).rev() {",
      "            st.update(i);",
      "        }",
      "        st",
      "    }",
      "    pub fn set(&mut self, p: usize, x: S) {",
      "        let p = p + self.size;",
      "        self.d[p] = x;",
      "        for i in 1..=self.log {",
      "            self.update(p >> i);",
      "        }",
      "    }",
      "    pub fn get(&self, p: usize) -> &S {",
      "        &self.d[p + self.size]",
      "    }",
      "    pub fn prod(&mut self, l: usize, r: usize) -> S {",
      "        let mut sml = F::e();",
      "        let mut smr = F::e();",
      "        let mut l = l + self.size;",
      "        let mut r = r + self.size;",
      "        while l < r {",
      "            if l & 1 == 1 {",
      "                sml = F::op(&sml, &self.d[l]);",
      "                l += 1;",
      "            }",
      "            if r & 1 == 1 {",
      "                r -= 1;",
      "                smr = F::op(&self.d[r], &smr);",
      "            }",
      "            l >>= 1;",
      "            r >>= 1;",
      "        }",
      "        F::op(&sml, &smr)",
      "    }",
      "    pub fn all_prod(&self) -> S {",
      "        self.d[1].clone()",
      "    }",
      "    fn update(&mut self, k: usize) {",
      "        self.d[k] = F::op(&self.d[2 * k], &self.d[2 * k + 1]);",
      "    }",
      "    fn ceil_pow2(n: usize) -> usize {",
      "        let mut m = 1;",
      "        let mut log = 0;",
      "        while n > m {",
      "            m <<= 1;",
      "            log += 1;",
      "        }",
      "        log",
      "    }",
      "}"
    ]
  },
  "segtree-op": {
    "prefix": "segtree-op",
    "body": [
      "pub trait Op<S> {",
      "    fn op(lhs: &S, rhs: &S) -> S;",
      "    fn e() -> S;",
      "}"
    ]
  },
  "segtree-sum": {
    "prefix": "segtree-sum",
    "body": [
      "impl Op<i64> for Sum {",
      "    fn op(lhs: &i64, rhs: &i64) -> i64 {",
      "        lhs + rhs",
      "    }",
      "    fn e() -> i64 {",
      "        0",
      "    }",
      "}",
      "pub struct SegmentTree<S: Clone, F: Op<S>> {",
      "    n: usize,",
      "    log: usize,",
      "    size: usize,",
      "    d: Vec<S>,",
      "    _marker: PhantomData<F>,",
      "}",
      "pub trait Op<S> {",
      "    fn op(lhs: &S, rhs: &S) -> S;",
      "    fn e() -> S;",
      "}",
      "impl<S: Clone, F: Op<S>> SegmentTree<S, F> {",
      "    pub fn from(v: Vec<S>) -> SegmentTree<S, F> {",
      "        let n = v.len();",
      "        let log = Self::ceil_pow2(n);",
      "        let size = 1 << log;",
      "        let mut d = (0..2 * size).map(|_| F::e()).collect::<Vec<_>>();",
      "        for (i, x) in v.into_iter().enumerate() {",
      "            d[size + i] = x",
      "        }",
      "        let mut st = SegmentTree {",
      "            n,",
      "            log,",
      "            size,",
      "            d,",
      "            _marker: PhantomData,",
      "        };",
      "        for i in (1..=(size - 1)).rev() {",
      "            st.update(i);",
      "        }",
      "        st",
      "    }",
      "    pub fn set(&mut self, p: usize, x: S) {",
      "        let p = p + self.size;",
      "        self.d[p] = x;",
      "        for i in 1..=self.log {",
      "            self.update(p >> i);",
      "        }",
      "    }",
      "    pub fn get(&self, p: usize) -> &S {",
      "        &self.d[p + self.size]",
      "    }",
      "    pub fn prod(&mut self, l: usize, r: usize) -> S {",
      "        let mut sml = F::e();",
      "        let mut smr = F::e();",
      "        let mut l = l + self.size;",
      "        let mut r = r + self.size;",
      "        while l < r {",
      "            if l & 1 == 1 {",
      "                sml = F::op(&sml, &self.d[l]);",
      "                l += 1;",
      "            }",
      "            if r & 1 == 1 {",
      "                r -= 1;",
      "                smr = F::op(&self.d[r], &smr);",
      "            }",
      "            l >>= 1;",
      "            r >>= 1;",
      "        }",
      "        F::op(&sml, &smr)",
      "    }",
      "    pub fn all_prod(&self) -> S {",
      "        self.d[1].clone()",
      "    }",
      "    fn update(&mut self, k: usize) {",
      "        self.d[k] = F::op(&self.d[2 * k], &self.d[2 * k + 1]);",
      "    }",
      "    fn ceil_pow2(n: usize) -> usize {",
      "        let mut m = 1;",
      "        let mut log = 0;",
      "        while n > m {",
      "            m <<= 1;",
      "            log += 1;",
      "        }",
      "        log",
      "    }",
      "}",
      "pub struct Sum {}"
    ]
  },
  "sum-impl": {
    "prefix": "sum-impl",
    "body": [
      "impl Op<i64> for Sum {",
      "    fn op(lhs: &i64, rhs: &i64) -> i64 {",
      "        lhs + rhs",
      "    }",
      "    fn e() -> i64 {",
      "        0",
      "    }",
      "}"
    ]
  },
  "vvec": {
    "prefix": "vvec",
    "body": [
      "#[macro_export]",
      "macro_rules! vvec {",
      "    (\\$ val : expr ; \\$ a : expr , \\$ b : expr ) => {",
      "        vec![vec![\\$val; \\$b]; \\$a]",
      "    };",
      "}"
    ]
  },
  "vvvec": {
    "prefix": "vvvec",
    "body": [
      "#[macro_export]",
      "macro_rules! vvvec {",
      "    (\\$ val : expr ; \\$ a : expr , \\$ b : expr , \\$ c : expr ) => {",
      "        vec![vec![vec![\\$val; \\$c]; \\$b]; \\$a]",
      "    };",
      "}"
    ]
  }
}
